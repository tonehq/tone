# API Documentation — Tone

> Auto-generated by `generate-api-code-documentation` skill.
> Last updated: 2026-02-26

## Table of Contents
- [Models](#models)
  - [Core Models](#core-models)
  - [Enterprise Edition Models](#enterprise-edition-models)
- [API Endpoints](#api-endpoints)
  - [Core (Community Edition)](#core-community-edition)
    - [Module: Auth](#module-auth)
    - [Module: Users](#module-users)
    - [Module: Organizations](#module-organizations)
    - [Module: API Keys](#module-api-keys)
    - [Module: Services](#module-services)
    - [Module: Service Providers](#module-service-providers)
    - [Module: Agents](#module-agents)
    - [Module: Agent Configs](#module-agent-configs)
    - [Module: Agent Phone Numbers](#module-agent-phone-numbers)
    - [Module: Models](#module-models)
  - [Enterprise Edition](#enterprise-edition)
    - [Module: EE Auth](#module-ee-auth)
    - [Module: EE Users](#module-ee-users)
    - [Module: EE Organizations](#module-ee-organizations)
- [Authentication Reference](#authentication-reference)
- [Service Dependency Map](#service-dependency-map)

---

## Models

### Core Models

---

#### `User` → table: `users`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `email` (String, unique, indexed, not null)
- `username` (String, unique, indexed, nullable)
- `password_hash` (String, nullable) — bcrypt hashed; null for OAuth users
- `first_name`, `last_name` (String, nullable)
- `profile` (JSONB, nullable) — arbitrary user profile data
- `avatar_url` (String, nullable)
- `phone_number` (String, nullable)
- `auth_provider` (Enum: EMAIL, FIREBASE, GOOGLE, GITHUB, default=EMAIL)
- `firebase_uid` (String, nullable)
- `external_id` (String, nullable)
- `status` (Enum: PENDING, ACTIVE, SUSPENDED, DELETED, default=PENDING)
- `email_verified` (Boolean, default=False)
- `email_verified_at` (BigInt, nullable)
- `phone_verified` (Boolean, nullable)
- `phone_verified_at` (BigInt, nullable)
- `last_login_at` (BigInt, nullable)
- `user_metadata` (JSONB, nullable)
- `created_at` (BigInt) — Unix timestamp ms
- `updated_at` (BigInt) — Unix timestamp ms

---

#### `Member` → table: `members` (Core single-tenant)

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `user_id` (BigInt, ForeignKey → users.id, unique)
- `role` (Enum: OWNER, ADMIN, MEMBER, VIEWER)
- `custom_permissions` (JSONB, nullable)
- `status` (String, default="active")
- `created_by` (BigInt, ForeignKey → users.id, nullable)
- `joined_at` (BigInt)
- `last_activity_at` (BigInt, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `OrganizationInvite` → table: `organization_invites`

**Columns:**
- `id` (BigInt, primary_key)
- `uuid` (UUID, unique)
- `email` (String, unique)
- `name` (String, nullable)
- `role` (Enum: OWNER, ADMIN, MEMBER, VIEWER)
- `status` (Enum: PENDING, ACCEPTED, EXPIRED, CANCELLED)
- `invitation_token` (String, unique)
- `expires_at` (BigInt)
- `invited_by` (BigInt, ForeignKey → users.id)
- `accepted_by` (BigInt, ForeignKey → users.id, nullable)
- `accepted_at` (BigInt, nullable)
- `message` (Text, nullable)
- `custom_permissions` (JSONB, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `EmailVerification` → table: `email_verifications`

**Columns:**
- `id` (BigInt, primary_key)
- `user_id` (BigInt, ForeignKey → users.id)
- `email` (String)
- `code` (String) — short numeric/alphanumeric code
- `token` (String, unique) — longer secure token
- `verified` (Boolean, default=False)
- `expires_at` (BigInt)
- `attempts` (Integer, default=0)
- `max_attempts` (Integer)
- `verified_at` (BigInt, nullable)

**Constraints:**
- UniqueConstraint on `(email, code)`

---

#### `PasswordReset` → table: `password_resets`

**Columns:**
- `id` (BigInt, primary_key)
- `user_id` (BigInt, ForeignKey → users.id)
- `email` (String)
- `token` (String, unique)
- `used` (Boolean, default=False)
- `expires_at` (BigInt)
- `used_at` (BigInt, nullable)
- `ip_address` (String, nullable)
- `user_agent` (String, nullable)
- `created_at` (BigInt)

---

#### `OrganizationAccessRequest` → table: `organization_access_requests`

**Columns:**
- `id` (BigInt, primary_key)
- `user_id` (BigInt, ForeignKey → users.id, unique)
- `status` (Enum: PENDING, APPROVED, REJECTED)
- `message` (Text, nullable)
- `reviewed_by` (BigInt, ForeignKey → users.id, nullable)
- `reviewed_at` (BigInt, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `Agent` → table: `agents`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `name` (String, unique, not null)
- `description` (Text, nullable)
- `is_public` (Boolean, default=False)
- `tags` (JSONB, nullable)
- `total_calls` (Integer, default=0)
- `total_minutes` (Numeric, default=0)
- `average_rating` (Numeric, nullable)
- `created_by` (BigInt, ForeignKey → users.id)
- `created_at` (BigInt)
- `updated_at` (BigInt)

**Relationships:**
- `config` → AgentConfig (one-to-one via agent_id)
- `phone_numbers` → AgentPhoneNumbers (one-to-many)

---

#### `AgentConfig` → table: `agent_configs`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `agent_id` (BigInt, ForeignKey → agents.id, unique)
- `llm_service_id` (BigInt, ForeignKey → service_providers.id, nullable)
- `tts_service_id` (BigInt, ForeignKey → service_providers.id, nullable)
- `stt_service_id` (BigInt, ForeignKey → service_providers.id, nullable)
- `system_prompt` (Text, not null)
- `first_message` (Text, nullable) — bot's opening line
- `end_call_message` (Text, nullable)
- `voicemail_message` (Text, nullable)
- `llm_metadata` (JSON, nullable) — e.g. `{ "model": "gpt-4o" }`
- `tts_metadata` (JSON, nullable) — e.g. `{ "voice_id": "..." }`
- `stt_metadata` (JSON, nullable)
- `agent_metadata` (JSON, nullable) — vocabulary, language, filters, etc.
- `status` (String, default="active")
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `AgentPhoneNumbers` → table: `agent_phone_numbers`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `agent_id` (BigInt, ForeignKey → agents.id)
- `phone_number` (String, unique, not null)
- `phone_number_sid` (String, not null) — Twilio SID
- `phone_number_auth_token` (String, not null)
- `provider` (String, not null) — e.g. "twilio"
- `country_code` (String, nullable)
- `number_type` (String, nullable) — "local", "toll_free", "mobile"
- `capabilities` (JSONB, nullable) — e.g. `{ "sms": true, "voice": true }`
- `status` (String, default="active")
- `created_at` (BigInt)
- `updated_at` (BigInt)

**Constraints:**
- UniqueConstraint on `(agent_id, phone_number)`

---

#### `ApiKey` → table: `api_keys`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `service_provider_id` (BigInt, ForeignKey → service_providers.id)
- `name` (String, not null)
- `api_key_encrypted` (String, not null) — AES-256 encrypted
- `api_key_hint` (String, nullable) — first 4 + last 4 chars for display
- `description` (String, nullable)
- `additional_credentials` (JSONB, nullable) — extra auth fields (e.g. org ID)
- `status` (String, default="active")
- `is_valid` (Boolean, nullable)
- `last_validated_at` (BigInt, nullable)
- `validation_error` (Text, nullable)
- `last_used_at` (BigInt, nullable)
- `usage_count` (Integer, default=0)
- `rate_limit_config` (JSONB, nullable)
- `created_by` (BigInt, ForeignKey → users.id)
- `expires_at` (BigInt, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `ServiceProvider` → table: `service_providers`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `name` (String, not null)
- `display_name` (String, not null)
- `description` (Text, nullable)
- `provider_type` (String, not null) — "llm", "tts", "stt"
- `logo_url` (String, nullable)
- `website_url` (String, nullable)
- `documentation_url` (String, nullable)
- `base_url` (String, nullable)
- `auth_type` (String, not null) — "api_key", "oauth"
- `supports_streaming` (Boolean, default=False)
- `config_schema` (JSONB, nullable) — JSON Schema for config validation
- `status` (String, default="active")
- `is_system` (Boolean, default=False) — system-managed, immutable

**Constraints:**
- UniqueConstraint on `(name, provider_type)`

---

#### `Service` → table: `services`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `service_provider_id` (BigInt, ForeignKey → service_providers.id)
- `api_key_id` (BigInt, ForeignKey → api_keys.id, nullable)
- `name` (String, not null)
- `description` (Text, nullable)
- `service_type` (String, not null) — "llm", "tts", "stt"
- `config` (JSONB, not null) — provider-specific config
- `status` (String, default="active")
- `is_default` (Boolean, default=False)
- `is_public` (Boolean, default=False)
- `tags` (JSONB, nullable)
- `usage_count` (Integer, default=0)
- `last_used_at` (BigInt, nullable)
- `created_by` (BigInt, ForeignKey → users.id)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `Model` → table: `models`

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `uuid` (UUID, unique, default=uuid4)
- `service_provider_id` (BigInt, ForeignKey → service_providers.id)
- `name` (String, not null) — model identifier (e.g. "gpt-4o")
- `meta_data` (JSON, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

### Enterprise Edition Models

---

#### `EE Organization` → table: `organizations`

**Columns:**
- `id` (UUID, primary_key, default=uuid4)
- `name` (String, not null)
- `slug` (String, unique, indexed)
- `description` (Text, nullable)
- `logo_url` (String, nullable)
- `website_url` (String, nullable)
- `settings` (JSONB, nullable)
- `status` (Enum: ACTIVE, SUSPENDED, DELETED, default=ACTIVE)
- `created_by` (BigInt, ForeignKey → users.id)
- `subscription_plan` (String, default="free")
- `subscription_status` (String, default="active")
- `created_at` (BigInt)
- `updated_at` (BigInt)

---

#### `EE Member` → table: `members` (multi-tenant)

**Columns:**
- `id` (BigInt, primary_key, autoincrement)
- `user_id` (BigInt, ForeignKey → users.id)
- `organization_id` (UUID, ForeignKey → organizations.id)
- `role` (Enum: OWNER, ADMIN, MEMBER, VIEWER)
- `custom_permissions` (JSONB, nullable)
- `status` (String, default="active")
- `created_by` (BigInt, ForeignKey → users.id, nullable)
- `joined_at` (BigInt)
- `last_activity_at` (BigInt, nullable)
- `created_at` (BigInt)
- `updated_at` (BigInt)

**Constraints:**
- UniqueConstraint on `(user_id, organization_id)`

---

#### `EE OrganizationInvite` → table: `organization_invites` (org-scoped)

Same as Core OrganizationInvite plus:
- `organization_id` (UUID, ForeignKey → organizations.id)

---

#### `EE OrganizationAccessRequest` → table: `organization_access_requests` (org-scoped)

Same as Core AccessRequest plus:
- `organization_id` (UUID, ForeignKey → organizations.id)

---

## API Endpoints

### Core (Community Edition)

**Base URL:** `http://localhost:8002/api/v1`

---

### Module: Auth

**Prefix:** `/api/v1/auth`

---

#### `POST /api/v1/auth/signup` — Register new user

**Auth:** None
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| email | string | yes | User email address |
| password | string | yes | Plain-text password (hashed server-side) |
| username | string | no | Display username |
| profile | object | no | Arbitrary profile data (stored as JSONB) |

**Response:** `201 Created`
```json
{ "message": "...", "user_id": 1, "token": "..." }
```

**Error Responses:**
- `400` — Email and password are required

**Code Trace (Pseudo-code):**
```
FUNCTION signup(email, password, username, profile):
  1. CHECK if user with this email already exists
     → Query users WHERE email = email
     → IF exists: RAISE 400 "Email already registered"
  2. HASH password using bcrypt
  3. CREATE new User record (status=PENDING, email_verified=False)
  4. GENERATE email verification code
  5. SAVE EmailVerification record with expiry
  6. SEND verification email via EmailService (Resend)
  7. CREATE Member record linking user to the single org
  8. RETURN success response with user data
```

**Service Dependencies:** `AuthService.signup()`

---

#### `POST /api/v1/auth/signup_with_firebase` — Register via Firebase

**Auth:** `Authorization: Bearer <firebase_token>` header required
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| email | string | yes | Firebase-authenticated email |
| profile | object | no | Arbitrary profile data |

**Response:** `201 Created`

**Error Responses:**
- `400` — Email is required
- `401` — Invalid authorization header

**Code Trace (Pseudo-code):**
```
FUNCTION signup_with_firebase(firebase_token, email, profile):
  1. VERIFY firebase_token against Firebase project
  2. EXTRACT firebase_uid from verified token claims
  3. CHECK if user with this email or firebase_uid already exists
  4. CREATE User with auth_provider=FIREBASE, email_verified=True
  5. CREATE Member record
  6. GENERATE and RETURN JWT token
```

**Service Dependencies:** `AuthService.signup_with_firebase()`

---

#### `GET /api/v1/auth/resend_verification_email` — Resend email verification

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |

**Response:** `200 OK` — `{ "message": "Verification email sent" }`

**Code Trace (Pseudo-code):**
```
FUNCTION resend_verification_email(email):
  1. FIND user by email → IF not found: RAISE 404
  2. IF user.email_verified: RAISE 400 "Email already verified"
  3. GENERATE new verification code and token
  4. UPSERT EmailVerification record (reset attempts counter)
  5. SEND email via EmailService
  6. RETURN success
```

**Service Dependencies:** `AuthService.resend_verification_email()`

---

#### `GET /api/v1/auth/verify_user_email` — Verify email with code

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |
| code | string | yes |
| user_id | integer | yes |

**Response:** `200 OK`

**Error Responses:**
- `400` — Invalid or expired verification code

**Code Trace (Pseudo-code):**
```
FUNCTION verify_user_email(email, code, user_id):
  1. FIND EmailVerification WHERE user_id + email + code match
     → IF not found: RAISE 400 "Invalid verification code"
  2. CHECK expires_at > now()
     → IF expired: RAISE 400 "Verification code expired"
  3. CHECK attempts < max_attempts
  4. UPDATE user.email_verified = True, user.status = ACTIVE
  5. UPDATE verification.verified = True, verified_at = now()
  6. RETURN success
```

**Service Dependencies:** `AuthService.verify_user_email()`

---

#### `POST /api/v1/auth/login` — Email/password login

**Auth:** None
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| email | string | yes | User email |
| password | string | yes | Plain-text password |

**Response:** `200 OK`
```json
{ "token": "<jwt>", "user": { "id": 1, "email": "...", "role": "admin", ... } }
```

**Error Responses:**
- `400` — Email and password are required
- `401` — Invalid credentials
- `403` — Email not verified / Account suspended or deleted

**Code Trace (Pseudo-code):**
```
FUNCTION login(email, password):
  1. FIND user by email
     → IF not found: RAISE 401 "Invalid credentials"
  2. VERIFY bcrypt(password) matches user.password_hash
     → IF mismatch: RAISE 401 "Invalid credentials"
  3. CHECK user.email_verified == True
     → IF not: RAISE 403 "Please verify your email"
  4. CHECK user.status == ACTIVE
     → IF suspended/deleted: RAISE 403 "Account disabled"
  5. FIND Member record to extract role
  6. UPDATE user.last_login_at = now()
  7. GENERATE JWT { user_id, email } (Core) or { user_id, email, org_id, role } (EE)
  8. RETURN token + user data
```

**Service Dependencies:** `AuthService.login()`

---

#### `GET /api/v1/auth/forget-password` — Request password reset

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |

**Response:** `200 OK` (always, even if email not found — security)

**Code Trace (Pseudo-code):**
```
FUNCTION forgot_password(email):
  1. FIND user by email
     → IF not found: RETURN 200 silently (don't reveal existence)
  2. GENERATE secure reset token (UUID or random bytes)
  3. SAVE PasswordReset record with expiry (e.g. 1 hour)
  4. SEND password reset email via EmailService with token link
  5. RETURN success
```

**Service Dependencies:** `AuthService.forgot_password()`

---

#### `GET /api/v1/auth/acceptForgotPassword` — Reset password

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |
| password | string | yes |
| token | string | yes |

**Response:** `200 OK`

**Error Responses:**
- `400` — Invalid or expired reset token

**Code Trace (Pseudo-code):**
```
FUNCTION accept_forgot_password(email, password, token):
  1. FIND PasswordReset WHERE email + token + used = False
     → IF not found: RAISE 400 "Invalid reset token"
  2. CHECK expires_at > now()
     → IF expired: RAISE 400 "Reset token expired"
  3. HASH new password with bcrypt
  4. UPDATE user.password_hash
  5. UPDATE reset.used = True, reset.used_at = now()
  6. RETURN success
```

**Service Dependencies:** `AuthService.accept_forgot_password()`

---

### Module: Users

**Prefix:** `/api/v1/user`

---

#### `GET /api/v1/user/get_all_users_for_organization` — List active members

**Auth:** Requires valid JWT (`require_org_member`)

**Response:** `200 OK` — Array of `{ user_id, email, username, role, joined_at }`

**Code Trace (Pseudo-code):**
```
FUNCTION get_all_users_for_organization():
  1. QUERY members JOIN users WHERE member.status = "active"
  2. RETURN list with user + role info
```

**Service Dependencies:** `AuthService.get_all_users_for_organization()`

---

#### `GET /api/v1/user/get_all_invited_users_for_organization` — List pending invites

**Auth:** Requires valid JWT (`require_org_member`)

**Response:** `200 OK` — Array of pending invite objects

**Code Trace (Pseudo-code):**
```
FUNCTION get_all_invited_users_for_organization():
  1. QUERY organization_invites WHERE status = PENDING
  2. RETURN list of { email, name, role, invited_by, created_at }
```

**Service Dependencies:** `AuthService.get_all_invited_users_for_organization()`

---

### Module: Organizations

**Prefix:** `/api/v1/organization`

---

#### `POST /api/v1/organization/invite_user_to_organization` — Invite a user

**Auth:** Requires admin or owner role (`require_admin_or_owner`)
**Request Body:** JSON
| Field | Type | Required |
|---|---|---|
| name | string | yes |
| email | string | yes |
| role | string | yes — "admin", "member", or "viewer" |

**Response:** `200 OK`

**Error Responses:**
- `400` — Name, email, and role are required
- `409` — User already a member / Invite already pending

**Code Trace (Pseudo-code):**
```
FUNCTION invite_user_to_organization(name, email, role, invited_by):
  1. VALIDATE role is in allowed enum values
  2. CHECK if user with email is already an active member
     → IF yes: RAISE 409 "User already a member"
  3. CHECK if pending invite for this email already exists
     → IF yes: RAISE 409 "Invite already sent"
  4. GENERATE invite token (UUID)
  5. CREATE OrganizationInvite record (expires in 7 days)
  6. SEND invite email via EmailService with accept link
  7. RETURN success with invite details
```

**Service Dependencies:** `AuthService.invite_user_to_organization()`

---

#### `GET /api/v1/organization/accept_invitation` — Accept an invitation

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |
| code | string | yes |

**Response:** `200 OK` + JWT token

**Code Trace (Pseudo-code):**
```
FUNCTION accept_invitation(email, code):
  1. FIND OrganizationInvite WHERE email + token/code + status = PENDING
     → IF not found: RAISE 400 "Invalid or expired invite"
  2. CHECK expires_at > now()
  3. FIND or CREATE user by email
     → IF new user: set email_verified=True, status=ACTIVE
  4. CREATE Member record with invite's role
  5. UPDATE invite.status = ACCEPTED, accepted_at = now()
  6. GENERATE JWT for the newly added user
  7. RETURN success + token
```

**Service Dependencies:** `AuthService.accept_invitation()`

---

#### `DELETE /api/v1/organization/remove_user_from_organization` — Remove a member

**Auth:** Requires admin or owner role
**Query Params:**
| Param | Type | Required |
|---|---|---|
| user_id | integer | yes |

**Response:** `200 OK`

**Error Responses:**
- `403` — Cannot remove owner
- `404` — User not found in organization

**Code Trace (Pseudo-code):**
```
FUNCTION remove_user_from_organization(user_id):
  1. FIND Member record for user_id
     → IF not found: RAISE 404
  2. CHECK target member role != OWNER
     → IF owner: RAISE 403 "Cannot remove organization owner"
  3. CHECK requester has sufficient privilege over target role
  4. UPDATE member.status = "removed" (soft delete)
  5. RETURN success
```

**Service Dependencies:** `AuthService.remove_user_from_organization()`

---

#### `POST /api/v1/organization/update_member_role` — Change a member's role

**Auth:** Requires admin or owner role
**Query Params:**
| Param | Type | Required |
|---|---|---|
| member_id | integer | yes |
| role | string | yes |

**Response:** `200 OK` — Updated member record

**Code Trace (Pseudo-code):**
```
FUNCTION update_member_role(member_id, role):
  1. FIND Member by member_id → IF not found: RAISE 404
  2. VALIDATE role is a valid enum value
  3. ENFORCE requester cannot assign role higher than their own
  4. UPDATE member.role = role
  5. RETURN updated member
```

**Service Dependencies:** `AuthService.update_member_role()`

---

#### `GET /api/v1/organization/settings` — Get organization settings

**Auth:** Requires org member JWT

**Response:** `200 OK` — Organization settings JSONB object

**Service Dependencies:** `AuthService.get_organization_settings()`

---

#### `PUT /api/v1/organization/settings` — Update organization settings

**Auth:** Requires admin or owner role
**Request Body:** JSON — arbitrary settings key/value pairs

**Response:** `200 OK` — Updated settings

**Code Trace (Pseudo-code):**
```
FUNCTION update_organization_settings(settings_data):
  1. MERGE settings_data into existing organization.settings JSONB
  2. SAVE and RETURN updated settings
```

**Service Dependencies:** `AuthService.update_organization_settings()`

---

#### `GET /api/v1/organization/access_requests` — List pending access requests

**Auth:** Requires admin or owner role

**Response:** `200 OK` — Array of access request objects with user info

**Service Dependencies:** `AuthService.get_access_requests()`

---

#### `POST /api/v1/organization/handle_access_request` — Approve or reject access

**Auth:** Requires admin or owner role
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| request_id | integer | yes | Access request ID |
| action | string | yes | `"approve"` or `"reject"` |

**Response:** `200 OK`

**Error Responses:**
- `400` — Request ID and action are required
- `404` — Access request not found

**Code Trace (Pseudo-code):**
```
FUNCTION handle_access_request(request_id, action, handled_by):
  1. FIND OrganizationAccessRequest by request_id WHERE status = PENDING
     → IF not found: RAISE 404
  2. IF action == "approve":
     a. CREATE Member record for requesting user with default role (MEMBER)
     b. UPDATE request.status = APPROVED
     c. SEND approval notification email
  3. IF action == "reject":
     a. UPDATE request.status = REJECTED
     b. SEND rejection notification email
  4. SET request.reviewed_by = handled_by, reviewed_at = now()
  5. RETURN success
```

**Service Dependencies:** `AuthService.handle_access_request()`

---

#### `GET /api/v1/organization/roles` — List available roles

**Auth:** Requires valid JWT

**Response:** `200 OK` — `["owner", "admin", "member", "viewer"]`

**Service Dependencies:** `AuthService.get_roles_by_scope()`

---

### Module: API Keys

**Prefix:** `/api/v1/api-keys`

---

#### `POST /api/v1/api-keys/upsert` — Create or update an API key

**Auth:** Requires admin or owner role
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| service_provider_id | integer | yes | Linked service provider |
| name | string | yes | Human-readable label |
| api_key | string | yes | Raw API key (AES-256 encrypted at rest) |
| description | string | no | Optional description |
| additional_credentials | object | no | Extra auth fields (e.g. org ID) |
| rate_limit_config | object | no | Rate limiting rules |
| expires_at | integer | no | Unix timestamp expiry |
| uuid | string | no | Provide to update an existing key |
| status | string | no | `"active"` or `"inactive"` |

**Response:** `200 OK` — ApiKey record (encrypted value masked, hint shown)

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_api_key(service_provider_id, name, api_key_value, ...):
  1. IF uuid provided:
     a. FIND ApiKey by uuid → IF not found: RAISE 404
     b. UPDATE fields
     c. IF new api_key_value provided: RE-ENCRYPT with AES-256
  2. ELSE:
     a. ENCRYPT api_key_value with AES-256
     b. GENERATE hint: first 4 + "..." + last 4 chars
     c. CREATE new ApiKey record with created_by = user_id
  3. SAVE to database
  4. RETURN ApiKey (encrypted value NOT returned, hint shown)
```

**Service Dependencies:** `ApiKeyService.upsert_api_key()`

---

#### `GET /api/v1/api-keys/list` — List all API keys

**Auth:** Requires valid JWT

**Response:** `200 OK` — Array of ApiKey records with provider info (encrypted values masked)

**Service Dependencies:** `ApiKeyService.get_all_api_keys()`

---

#### `GET /api/v1/api-keys/get` — Get a single API key

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| api_key_id | integer | yes |

**Response:** `200 OK`

**Service Dependencies:** `ApiKeyService.get_api_key()`

---

#### `DELETE /api/v1/api-keys/delete` — Delete an API key

**Auth:** Requires admin or owner role
**Query Params:**
| Param | Type | Required |
|---|---|---|
| api_key_id | integer | yes |

**Response:** `200 OK`

**Service Dependencies:** `ApiKeyService.delete_api_key()`

---

#### `POST /api/v1/api-keys/validate` — Mark API key valid/invalid

**Auth:** Requires admin or owner role
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| api_key_id | integer | yes | Key to update |
| is_valid | boolean | yes | Validation result |
| validation_error | string | no | Error message if invalid |

**Response:** `200 OK`

**Code Trace (Pseudo-code):**
```
FUNCTION validate_api_key(api_key_id, is_valid, validation_error):
  1. FIND ApiKey by api_key_id → IF not found: RAISE 404
  2. UPDATE api_key.is_valid = is_valid
  3. UPDATE api_key.last_validated_at = now()
  4. IF not is_valid: SET api_key.validation_error = validation_error
  5. SAVE and RETURN
```

**Service Dependencies:** `ApiKeyService.validate_api_key()`

---

### Module: Services

**Prefix:** `/api/v1/services`

---

#### `POST /api/v1/services/upsert` — Create or update a service configuration

**Auth:** Requires admin or owner role
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| service_provider_id | integer | yes | Linked provider |
| name | string | yes | Service name |
| service_type | string | yes | `"llm"`, `"tts"`, or `"stt"` |
| config | object | yes | Provider-specific config (model, voice, etc.) |
| api_key_id | integer | no | Linked API key |
| description | string | no | |
| is_default | boolean | no | Set as default for this service_type |
| is_public | boolean | no | Shared across users |
| tags | object | no | Tag metadata |
| uuid | string | no | Provide to update existing |
| status | string | no | `"active"` or `"inactive"` |

**Response:** `200 OK`

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_service(service_provider_id, name, service_type, config, ...):
  1. IF uuid provided:
     a. FIND Service by uuid → UPDATE fields
  2. ELSE:
     a. CREATE new Service record with created_by = user_id
  3. IF is_default == True:
     a. UPDATE all other services WHERE service_type = type → is_default = False
     b. SET this service is_default = True
  4. SAVE and RETURN
```

**Service Dependencies:** `ServiceConfigService.upsert_service()`

---

#### `GET /api/v1/services/list` — List services

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required | Description |
|---|---|---|---|
| service_type | string | no | Filter: `"llm"`, `"tts"`, `"stt"` |

**Response:** `200 OK` — Array of service records with joined provider info

**Service Dependencies:** `ServiceConfigService.get_all_services()`

---

#### `GET /api/v1/services/get` — Get a single service

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| service_id | integer | yes |

**Response:** `200 OK`

**Service Dependencies:** `ServiceConfigService.get_service()`

---

#### `GET /api/v1/services/default` — Get default service for a type

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| service_type | string | yes |

**Response:** `200 OK` — Single default service record

**Service Dependencies:** `ServiceConfigService.get_default_service()`

---

#### `DELETE /api/v1/services/delete` — Delete a service

**Auth:** Requires admin or owner role
**Query Params:**
| Param | Type | Required |
|---|---|---|
| service_id | integer | yes |

**Response:** `200 OK`

**Service Dependencies:** `ServiceConfigService.delete_service()`

---

### Module: Service Providers

**Prefix:** `/api/v1/service-providers`

---

#### `POST /api/v1/service-providers/upsert` — Create or update a service provider

**Auth:** Requires admin or owner role
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| name | string | yes | Internal identifier (e.g. `"openai"`) |
| display_name | string | yes | UI label (e.g. `"OpenAI"`) |
| provider_type | string | yes | `"llm"`, `"tts"`, `"stt"` |
| auth_type | string | yes | `"api_key"`, `"oauth"` |
| description | string | no | |
| logo_url | string | no | |
| website_url | string | no | |
| documentation_url | string | no | |
| base_url | string | no | API base URL override |
| supports_streaming | boolean | no | |
| config_schema | object | no | JSON Schema for config validation |
| is_system | boolean | no | System-managed (immutable by users) |
| status | string | no | `"active"` or `"inactive"` |
| id | integer | no | Provide to update existing |

**Response:** `200 OK`

**Service Dependencies:** `ServiceProviderService.upsert_service_provider()`

---

#### `GET /api/v1/service-providers/list` — List service providers

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| provider_type | string | no |

**Response:** `200 OK` — Array of providers with their associated models

**Service Dependencies:** `ServiceProviderService.get_all_service_providers()`

---

#### `GET /api/v1/service-providers/get` — Get a single provider

**Auth:** Requires valid JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| provider_id | integer | yes |

**Response:** `200 OK`

**Service Dependencies:** `ServiceProviderService.get_service_provider()`

---

#### `DELETE /api/v1/service-providers/delete` — Delete a service provider

**Auth:** Requires admin or owner role
**Query Params:**
| Param | Type | Required |
|---|---|---|
| provider_id | integer | yes |

**Error Responses:**
- `403` — Cannot delete system providers (`is_system = True`)

**Service Dependencies:** `ServiceProviderService.delete_service_provider()`

---

### Module: Agents

**Prefix:** `/api/v1/agent`

---

#### `GET /api/v1/agent/get_all_agents` — List agents

**Auth:** Requires org member JWT
**Query Params:**
| Param | Type | Required | Description |
|---|---|---|---|
| agent_id | integer | no | If provided, returns only this specific agent |

**Response:** `200 OK` — Array of flattened agent objects (agent + config + provider info)

**Code Trace (Pseudo-code):**
```
FUNCTION get_all_agents(agent_id, created_by):
  1. QUERY agents WHERE created_by = user_id
     AND optionally WHERE id = agent_id
  2. LEFT JOIN agent_configs ON agent.id = config.agent_id
  3. LEFT JOIN service_providers AS llm_provider ON config.llm_service_id
  4. LEFT JOIN service_providers AS tts_provider ON config.tts_service_id
  5. LEFT JOIN service_providers AS stt_provider ON config.stt_service_id
  6. FLATTEN result: merge agent fields + config fields into single dict
  7. RETURN list
```

**Service Dependencies:** `AgentService.get_all_agents()`

---

#### `POST /api/v1/agent/upsert_agent` — Create or update an agent

**Auth:** Requires org member JWT
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| name | string | yes | Unique agent name |
| description | string | no | |
| is_public | boolean | no | |
| tags | object | no | |
| uuid | string | no | Provide to update existing agent |

**Response:** `200 OK` — Upserted agent record

**Error Responses:**
- `400` — name is required
- `409` — Agent name already taken

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_agent(data, created_by):
  1. IF uuid in data:
     a. FIND Agent by uuid → IF not found: RAISE 404
     b. UPDATE provided fields
  2. ELSE:
     a. CHECK Agent WHERE name = data.name does not exist
        → IF exists: RAISE 409 "Agent name already taken"
     b. CREATE new Agent with created_by = user_id
  3. SAVE and RETURN flattened agent + config response
```

**Service Dependencies:** `AgentService.upsert_agent()`

---

### Module: Agent Configs

**Prefix:** `/api/v1/agent_config`

---

#### `POST /api/v1/agent_config/upsert_agent_config` — Create or update agent config

**Auth:** Requires org member JWT
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| agent_id | integer | yes | Target agent ID |
| system_prompt | string | yes | LLM system instructions |
| llm_service_id | integer | no | Linked LLM service |
| tts_service_id | integer | no | Linked TTS service |
| stt_service_id | integer | no | Linked STT service |
| first_message | string | no | Bot's opening line |
| end_call_message | string | no | Bot's sign-off message |
| voicemail_message | string | no | Message left on voicemail |
| llm_metadata | object | no | e.g. `{ "model": "gpt-4o", "temperature": 0.7 }` |
| tts_metadata | object | no | e.g. `{ "voice_id": "abc123" }` |
| stt_metadata | object | no | |
| agent_metadata | object | no | vocabulary, language, filter words, voice speed, etc. |

**Response:** `200 OK` — Upserted agent config

**Error Responses:**
- `400` — agent_id is required
- `400` — system_prompt is required

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_agent_config(data):
  1. FIND Agent by agent_id → IF not found: RAISE 404
  2. FIND existing AgentConfig WHERE agent_id = data.agent_id
  3. IF exists: UPDATE all provided fields
  4. ELSE: CREATE new AgentConfig record
  5. SAVE and RETURN config
```

**Service Dependencies:** `AgentConfigService.upsert_agent_config()`

---

### Module: Agent Phone Numbers

**Prefix:** `/api/v1/agent_phone_number`

---

#### `POST /api/v1/agent_phone_number/upsert_agent_phone_number` — Assign phone number to agent

**Auth:** Requires org member JWT
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| agent_id | integer | yes | Target agent |
| phone_number | string | yes | E.164 format e.g. `+12025551234` |
| phone_number_sid | string | yes | Twilio Phone Number SID |
| phone_number_auth_token | string | yes | Twilio auth token |
| provider | string | yes | e.g. `"twilio"` |
| country_code | string | no | ISO country code |
| number_type | string | no | `"local"`, `"toll_free"`, `"mobile"` |
| capabilities | object | no | `{ "sms": true, "voice": true }` |
| uuid | string | no | Provide to update existing |

**Response:** `200 OK`

**Error Responses:**
- `400` — agent_id, phone_number, phone_number_sid, phone_number_auth_token, provider are all required
- `409` — Phone number already assigned to another agent

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_agent_phone_number(data):
  1. FIND Agent by agent_id → IF not found: RAISE 404
  2. IF uuid provided:
     a. FIND AgentPhoneNumbers by uuid → UPDATE fields
  3. ELSE:
     a. CHECK phone_number is not already in use
        → IF duplicate: RAISE 409 "Phone number already assigned"
     b. CREATE new AgentPhoneNumbers record
  4. SAVE and RETURN
```

**Service Dependencies:** `AgentPhoneNumbersService.upsert_agent_phone_number()`

---

### Module: Models

**Prefix:** `/api/v1/model`

---

#### `POST /api/v1/model/upsert_model` — Create or update an LLM model

**Auth:** Requires org member JWT
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| id | integer | no | Provide to update existing |
| service_provider_id | integer | required for create | Linked provider |
| name | string | required for create | Model identifier e.g. `"gpt-4o"` |
| meta_data | object | no | Provider-specific metadata |

**Response:** `200 OK`

**Code Trace (Pseudo-code):**
```
FUNCTION upsert_model(data):
  1. IF id provided:
     a. FIND Model by id → IF not found: RAISE 404
     b. UPDATE provided fields
  2. ELSE:
     a. VALIDATE service_provider_id and name are present
     b. FIND ServiceProvider by service_provider_id → IF not found: RAISE 404
     c. CREATE new Model record
  3. SAVE and RETURN
```

**Service Dependencies:** `ModelService.upsert_model()`

---

## Enterprise Edition

**Base URL:** `http://localhost:8000/api/v1`

> The EE is a multi-tenant extension of the Core edition.
> All organization-scoped operations require `org_id` in JWT claims.
> Organization router is mounted under **both** `/api/v1/org` and `/api/v1/organization`.

---

### Module: EE Auth

**Prefix:** `/api/v1/auth`

All Core auth endpoints are present with the same signatures, using `EEAuthService`.

---

#### `POST /api/v1/auth/signup` — Register with optional org creation (EE)

**Auth:** None
**Request Body:** JSON
| Field | Type | Required | Description |
|---|---|---|---|
| email | string | yes | |
| password | string | yes | |
| username | string | no | |
| profile | object | no | |
| org_name | string | no | If provided, creates an organization and adds user as OWNER |

**Response:** `201 Created`

**Code Trace (Pseudo-code):**
```
FUNCTION ee_signup(email, password, username, profile, org_name):
  1. Run Core signup flow (CREATE user, SEND verification email)
  2. IF org_name provided:
     a. GENERATE slug from org_name (lowercase, hyphens)
     b. CHECK slug uniqueness in organizations
        → IF taken: append numeric suffix until unique
     c. CREATE Organization record with status=ACTIVE
     d. CREATE Member record: user as OWNER
  3. GENERATE JWT with { user_id, email, org_id, role }
  4. RETURN user + org data
```

**Service Dependencies:** `EEAuthService.signup()`

---

#### `GET /api/v1/auth/check_organization_exists` — Check org name availability **(EE only)**

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| name | string | yes |

**Response:** `200 OK` — `{ "exists": true/false }`

**Code Trace (Pseudo-code):**
```
FUNCTION check_organization_exists(name):
  1. GENERATE slug from name
  2. QUERY organizations WHERE slug = slug
  3. RETURN { "exists": record_found }
```

**Service Dependencies:** `EEAuthService.check_organization_exists()`

---

#### `POST /api/v1/auth/switch_organization` — Switch active organization **(EE only)**

**Auth:** Requires valid EE JWT
**Request Body:** JSON
| Field | Type | Required |
|---|---|---|
| organization_id | string (UUID) | yes |

**Response:** `200 OK` — New JWT token with updated `org_id` + `role` claims

**Error Responses:**
- `400` — Organization ID is required
- `403` — Not a member of this organization

**Code Trace (Pseudo-code):**
```
FUNCTION switch_organization(user_id, org_id):
  1. FIND Member WHERE user_id = user_id AND organization_id = org_id
     → IF not found: RAISE 403 "Not a member of this organization"
  2. CHECK member.status == "active"
  3. GENERATE new JWT: { user_id, email, org_id, role: member.role }
  4. RETURN new token
```

**Service Dependencies:** `EEAuthService.switch_organization()`

---

### Module: EE Users

**Prefix:** `/api/v1/user`

Same endpoints as Core but scoped to `org_id` from JWT claims.

---

#### `GET /api/v1/user/get_all_users_for_organization` — List org members (EE)

**Auth:** Requires EE org member JWT (`require_ee_org_member`)

**Code Trace (Pseudo-code):**
```
FUNCTION ee_get_all_users_for_organization(org_id):
  1. QUERY members JOIN users
     WHERE members.organization_id = org_id AND member.status = "active"
  2. RETURN list
```

**Service Dependencies:** `EEAuthService.get_all_users_for_organization(org_id)`

---

#### `GET /api/v1/user/get_all_invited_users_for_organization` — List pending invites (EE)

**Auth:** Requires EE org member JWT

**Code Trace (Pseudo-code):**
```
FUNCTION ee_get_all_invited_users_for_organization(org_id):
  1. QUERY organization_invites
     WHERE organization_id = org_id AND status = PENDING
  2. RETURN list
```

**Service Dependencies:** `EEAuthService.get_all_invited_users_for_organization(org_id)`

---

### Module: EE Organizations

**Prefix:** `/api/v1/org` AND `/api/v1/organization`

---

#### `GET /api/v1/org/get_associated_tenants` — Get user's organizations **(EE only)**

**Auth:** Requires valid EE JWT

**Response:** `200 OK` — Array of orgs with user's role in each

**Code Trace (Pseudo-code):**
```
FUNCTION get_associated_organizations(user_id):
  1. QUERY members JOIN organizations
     WHERE user_id = user_id AND member.status = "active"
  2. RETURN list of { org_id, name, slug, logo_url, role }
```

**Service Dependencies:** `EEAuthService.get_associated_organizations()`

---

#### `POST /api/v1/org/create_tenants` — Create a new organization **(EE only)**

**Auth:** Requires valid EE JWT
**Query Params:**
| Param | Type | Required |
|---|---|---|
| name | string | yes |

**Response:** `200 OK` — Created organization + OWNER membership

**Code Trace (Pseudo-code):**
```
FUNCTION create_organization(name, user_id):
  1. GENERATE slug from name
  2. CHECK slug uniqueness → append suffix if needed
  3. CREATE Organization with created_by = user_id, status = ACTIVE
  4. CREATE Member record with role = OWNER
  5. RETURN organization data
```

**Service Dependencies:** `EEAuthService.create_organization()`

---

#### `POST /api/v1/org/invite_user_to_organization` — Invite user to org (EE)

**Auth:** Requires EE admin or owner role
**Request Body:** JSON — `{ name, email, role }`

Identical logic to Core but scoped to `org_id` from JWT.

**Service Dependencies:** `EEAuthService.invite_user_to_organization(org_id, ...)`

---

#### `GET /api/v1/org/accept_invitation` — Accept org invite (EE)

**Auth:** None
**Query Params:**
| Param | Type | Required |
|---|---|---|
| email | string | yes |
| code | string | yes |
| user_tenant_id | string (UUID) | yes | Organization UUID |

**Service Dependencies:** `EEAuthService.accept_invitation(email, code, org_id)`

---

#### `DELETE /api/v1/org/remove_user_from_organization` — Remove member (EE)

**Auth:** Requires EE admin or owner role
**Query Params:** `user_id` (integer)

**Service Dependencies:** `EEAuthService.remove_user_from_organization(org_id, user_id)`

---

#### `POST /api/v1/org/update_member_role` — Update member role (EE)

**Auth:** Requires EE admin or owner role
**Query Params:** `member_id` (integer), `role` (string)

**Service Dependencies:** `EEAuthService.update_member_role(org_id, member_id, role)`

---

#### `GET /api/v1/org/settings` — Get org settings (EE)

**Auth:** Requires EE org member JWT

**Service Dependencies:** `EEAuthService.get_organization_settings(org_id)`

---

#### `PUT /api/v1/org/settings` — Update org settings (EE)

**Auth:** Requires EE admin or owner role
**Request Body:** JSON — arbitrary settings key/value pairs

**Service Dependencies:** `EEAuthService.update_organization_settings(org_id, settings_data)`

---

#### `POST /api/v1/org/request_access` — Request to join an org **(EE only)**

**Auth:** Requires valid EE JWT
**Request Body:** JSON
| Field | Type | Required |
|---|---|---|
| org_id | string (UUID) | yes |
| message | string | no |

**Response:** `200 OK`

**Code Trace (Pseudo-code):**
```
FUNCTION request_organization_access(user_id, org_id, message):
  1. CHECK org exists → IF not: RAISE 404
  2. CHECK user is NOT already a member (org-scoped)
  3. CHECK no PENDING request already exists for (user_id, org_id)
  4. CREATE OrganizationAccessRequest with organization_id = org_id
  5. NOTIFY org admins/owners via email
  6. RETURN success
```

**Service Dependencies:** `EEAuthService.request_organization_access()`

---

#### `GET /api/v1/org/access_requests` — List access requests (EE)

**Auth:** Requires EE admin or owner role

**Response:** `200 OK` — Pending access requests for caller's org

**Service Dependencies:** `EEAuthService.get_access_requests(org_id)`

---

#### `POST /api/v1/org/handle_access_request` — Handle access request (EE)

**Auth:** Requires EE admin or owner role
**Request Body:** JSON — `{ request_id, action }`

**Service Dependencies:** `EEAuthService.handle_access_request(org_id, request_id, action, handled_by)`

---

#### `GET /api/v1/org/roles` — List roles (EE)

**Auth:** Requires valid EE JWT

**Response:** `200 OK` — `["owner", "admin", "member", "viewer"]`

**Service Dependencies:** `EEAuthService.get_roles_by_scope()`

---

## Authentication Reference

### JWT Payload Structure

**Core Edition:**
```json
{
  "user_id": 1,
  "email": "user@example.com",
  "exp": 1234567890,
  "iat": 1234567890
}
```

**Enterprise Edition:**
```json
{
  "user_id": 1,
  "email": "user@example.com",
  "org_id": "550e8400-e29b-41d4-a716-446655440000",
  "role": "admin",
  "exp": 1234567890,
  "iat": 1234567890
}
```

### Dependency Guard Reference

| Guard | File | Description |
|---|---|---|
| `get_jwt_claims` | `core/middleware/auth.py` | Validates JWT; raises 401 if invalid |
| `get_optional_jwt_claims` | `core/middleware/auth.py` | Optional auth; returns None if no token |
| `require_org_member` | `core/middleware/auth.py` | Auth required; confirms active membership |
| `require_admin_or_owner` | `core/middleware/auth.py` | Role must be ADMIN or OWNER |
| `require_owner` | `core/middleware/auth.py` | Role must be OWNER only |
| `get_ee_jwt_claims` | `ee/middleware/auth.py` | EE version; requires org_id in token |
| `get_ee_current_user` | `ee/middleware/auth.py` | EE auth with optional `tenant_id` header override |
| `require_ee_org_member` | `ee/middleware/auth.py` | Validates user_id + org_id present |
| `require_ee_admin_or_owner` | `ee/middleware/auth.py` | EE role check with org context |
| `require_ee_owner` | `ee/middleware/auth.py` | EE owner-only check |

### Supported Auth Providers

| Provider | `auth_provider` value | Notes |
|---|---|---|
| Email/Password | `EMAIL` | bcrypt hashed password |
| Firebase | `FIREBASE` | Token verified server-side |
| Google | `GOOGLE` | OAuth flow |
| GitHub | `GITHUB` | OAuth flow |

---

## Bot Pipeline Reference

The bot system (not exposed as REST API — internal) uses:

### `AgentFactoryService`
Builds and runs voice bot pipelines via [Pipecat](https://github.com/pipecat-ai/pipecat).

**Supported LLM Providers:** OpenAI, Anthropic, Groq, OpenRouter
**Supported STT Providers:** Deepgram, OpenAI, Groq
**Supported TTS Providers:** Cartesia, OpenAI, ElevenLabs, PlayHT

```
FUNCTION run_bot_for_agent(agent_config):
  1. FETCH agent config with service IDs
  2. DECRYPT API keys via ApiKeyService
  3. INSTANTIATE LLM client (e.g. OpenAILLMService)
  4. INSTANTIATE STT client (e.g. DeepgramSTTService)
  5. INSTANTIATE TTS client (e.g. CartesiaTTSService)
  6. BUILD Pipecat pipeline with RTVI observer
  7. INJECT system_prompt + first_message as initial context
  8. RUN async pipeline until call ends
```

### `BotRunnerService`
Routes incoming Twilio phone calls to the correct agent.

```
FUNCTION get_bot_for_incoming_call(websocket_message):
  1. PARSE WebSocket message from Twilio transport
  2. EXTRACT incoming phone number ("to" field)
  3. IF "to" not in message: CALL Twilio API to fetch call metadata
  4. QUERY AgentPhoneNumbers WHERE phone_number = incoming_number
  5. RETURN matched Agent record
```

---

## Service Dependency Map

| Service | Depends On | Used By |
|---|---|---|
| `AuthService` | `EmailService` (Resend) | `core/api/v1/auth.py`, `users.py`, `organizations.py` |
| `EEAuthService` | `EmailService` (Resend) | `ee/api/v1/auth.py`, `users.py`, `organizations.py` |
| `ApiKeyService` | — | `core/api/v1/api_keys.py` |
| `ServiceConfigService` | — | `core/api/v1/services.py` |
| `ServiceProviderService` | — | `core/api/v1/service_providers.py` |
| `AgentService` | — | `core/api/v1/agents.py` |
| `AgentConfigService` | — | `core/api/v1/agent_configs.py` |
| `AgentPhoneNumbersService` | — | `core/api/v1/agent_phone_numbers.py` |
| `ModelService` | — | `core/api/v1/models.py` |
| `AgentFactoryService` | `ApiKeyService`, `ServiceConfigService` | `core/bot.py` (Pipecat pipeline) |
| `BotRunnerService` | `AgentPhoneNumbersService`, `AgentFactoryService` | `core/bot.py` (Twilio webhook) |
| `EmailService` | Resend API (external) | `AuthService`, `EEAuthService` |
